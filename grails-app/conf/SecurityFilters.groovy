/**
 * Generated by the Shiro plugin. This filters class protects all URLs
 * via access control by convention.
 */

import au.org.biodiversity.nsl.ApiKeyToken
import org.apache.shiro.SecurityUtils
import org.apache.shiro.authc.AuthenticationException
import org.codehaus.groovy.grails.web.util.WebUtils

import static org.springframework.http.HttpStatus.*

class SecurityFilters {

    def filters = {

        all(uri: "/**") {
            before = {

                //need the .format to get a good response in case of errors
                String requested = (WebUtils.getForwardURI(request) ?: request.getAttribute('javax.servlet.error.request_uri'))
                requested = requested.decodeURL()

                if (requested.endsWith('.json')) {
                    params.format = 'json'
                }
                if (requested.endsWith('.xml')) {
                    params.format = 'xml'
                }
                if (requested.endsWith('.html')) {
                    params.format = 'html'
                }

                //if an apiKey is set then login with it
                if (params.apiKey) {
                    try {
                        String apiKey = params.remove('apiKey')
                        ApiKeyToken authToken = new ApiKeyToken(apiKey, null as char[], SecurityUtils.subject.host as String)
                        Long start = System.currentTimeMillis()
                        SecurityUtils.subject.login(authToken)
                        log.debug "login took ${System.currentTimeMillis() - start}ms"
                        return true
                    } catch (AuthenticationException e) {
                        log.info e.message
                        redirect(controller: 'auth', action: 'unauthorized', params: [format: params.format])
                        return false
                    }
                }
            }
        }

        notApi(uri: "/**") {
            before = {
                if (controllerName && controllerName =~ /(admin)/) {
                    accessControl(auth: true) {
                        //stop access to edit and delete in the base actions for now.
                        !actionName.equals('delete') && !actionName.equals('edit')
                    }
                } else {
                    return true
                }
            }
        }
    }
}
